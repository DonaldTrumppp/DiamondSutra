<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Reader</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Reading: My Large Text File</h1>
    </header>
    <main>
        <div id="text-container"></div>
        <div id="pagination">
            <button id="prev-btn" disabled>Previous</button>
            <span id="page-info">Page 1 of 1</span>
            <button id="next-btn">Next</button>
        </div>
    </main>
    <script>
        // Assume `fullText` is loaded as a big string (e.g., fetched from raw GitHub URL or embedded)
        // Example separator: "1．", "2．"
        function splitIntoSections(fullText) {
          // Keep the marker by using a capturing group and split-on-boundaries
          const parts = fullText.split(/(?=\d．)/g); // lookahead to keep "n．" at the start of each part
          return parts.map((content, idx) => ({
            id: `section-${idx + 1}`,
            title: content.match(/^\d．/)?.[0] ?? `Section ${idx + 1}`,
            content
          }));
        }
    </script>
    <!-- Firebase SDKs -->
<script type="module">
    // Import from CDN
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getAuth, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, serverTimestamp, onSnapshot } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
  
    // 1) Your Firebase config (from console)
    const firebaseConfig = {
      apiKey: "AIzaSyC9FBAPW12b2mXQ3-HRrlln7lrxgFQ6cyI",
      authDomain: "http://diamondsutra-30da1.firebaseapp.com/",
      projectId: "diamondsutra-30da1",
    };
  
    // 2) Init Firebase
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
  
    // 3) Sign-in (Anonymous)
    async function ensureSignedIn() {
      return new Promise((resolve, reject) => {
        onAuthStateChanged(auth, async (user) => {
          try {
            if (!user) {
              await signInAnonymously(auth);
            }
            resolve(auth.currentUser);
          } catch (e) {
            reject(e);
          }
        });
      });
    }
  
    // 4) References
    function progressDocRef(uid) {
      return doc(db, "users", uid, "reading", "progress");
    }
  
    // 5) Save progress (debounced)
    let saveTimer = null;
    function saveProgress(uid, currentSectionId, offsetPx) {
      if (saveTimer) clearTimeout(saveTimer);
      saveTimer = setTimeout(async () => {
        await setDoc(progressDocRef(uid), {
          currentSectionId,
          offsetPx,
          updatedAt: serverTimestamp()
        }, { merge: true });
      }, 400); // debounce to avoid spamming writes while scrolling
    }
  
    // 6) Load and live sync progress
    async function subscribeProgress(uid, onUpdate) {
      return onSnapshot(progressDocRef(uid), (snap) => {
        if (snap.exists()) {
          const data = snap.data();
          onUpdate(data.currentSectionId, data.offsetPx || 0, data.updatedAt);
        } else {
          onUpdate(null, 0, null);
        }
      });
    }
  
    // 7) Hook into UI (example)
    // Setup: sections array, content container, navigation, scroll tracking
    let sections = []; // Fill after text load
    let currentIndex = 0;
  
    function renderSection(index) {
      const section = sections[index];
      const container = document.getElementById("content");
      container.textContent = section.content;
      currentIndex = index;
      // reset scroll and then apply synced offset if available
      window.scrollTo(0, 0);
    }
  
    function findIndexById(id) {
      return sections.findIndex(s => s.id === id);
    }
  
    function onScroll(uid) {
      const offsetPx = window.scrollY || document.documentElement.scrollTop || 0;
      const currentSectionId = sections[currentIndex]?.id;
      if (currentSectionId) {
        saveProgress(uid, currentSectionId, offsetPx);
      }
    }
  
    // 8) Init app
    async function initReader(fullText) {
      sections = splitIntoSections(fullText);
  
      const user = await ensureSignedIn();
      renderSection(0);
  
      // Listen to remote progress changes (e.g., switching devices)
      const unsubscribe = await subscribeProgress(user.uid, (sectionId, offsetPx) => {
        if (sectionId) {
          const idx = findIndexById(sectionId);
          if (idx >= 0 && idx !== currentIndex) {
            renderSection(idx);
          }
          // Apply scroll offset after render
          window.requestAnimationFrame(() => {
            window.scrollTo(0, offsetPx || 0);
          });
        }
      });
  
      // Track scroll and save (debounced)
      window.addEventListener("scroll", () => onScroll(user.uid), { passive: true });
  
      // Next/Prev navigation example
      document.getElementById("nextBtn")?.addEventListener("click", () => {
        if (currentIndex < sections.length - 1) {
          renderSection(currentIndex + 1);
          // Immediately save at top of next section
          saveProgress(user.uid, sections[currentIndex].id, 0);
        }
      });
      document.getElementById("prevBtn")?.addEventListener("click", () => {
        if (currentIndex > 0) {
          renderSection(currentIndex - 1);
          saveProgress(user.uid, sections[currentIndex].id, 0);
        }
      });
    }
  
    // 9) Boot with your text
    // Replace this with your actual text load (e.g., fetch from raw GitHub URL)
    const fullText = 'text.txt';
    initReader(fullText);
  </script>
    <div id="content" style="white-space: pre-wrap; line-height: 1.6;"></div>
    <div style="position: fixed; bottom: 16px; right: 16px; display: flex; gap: 8px;">
      <button id="prevBtn">Prev</button>
      <button id="nextBtn">Next</button>
    </div>
    
    <!-- <script src="script.js"></script> -->
</body>
</html>